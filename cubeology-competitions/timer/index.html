<body>


  <meta charset="UTF-8">
  <title>Cubing Timer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    :root {
      --bg-color: #f8f9fa;
      --text-color: #212529;
      --card-bg: #fff;
      --accent: #007bff;
      --hover-accent: #0056b3;
      --ao5-color: #e76f51;
      --table-border: #dee2e6;
    }
    * {
      box-sizing: border-box;
    }
    body {
      margin: 0;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background-color: var(--bg-color);
      color: var(--text-color);
      display: flex;
      flex-direction: column;
      min-height: 100vh;
    }
html, body {
  -webkit-tap-highlight-color: transparent;
  -webkit-touch-callout: none; /* Prevent callout like long press text copy */
}

.modal {
  display: none;
  position: fixed;
  z-index: 9999;
  left: 0;
  top: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0,0,0,0.4);
}

.modal-content {
  background-color: var(--card-bg);
  margin: 10% auto;
  padding: 20px;
  border-radius: 12px;
  width: 300px;
  position: relative;
  box-shadow: 0 2px 8px rgba(0,0,0,0.2);
}

.modal .close {
  color: #aaa;
  position: absolute;
  right: 12px;
  top: 8px;
  font-size: 24px;
  font-weight: bold;
  cursor: pointer;
}

.modal-content label {
  display: block;
  margin-top: 10px;
}


    .container {
      display: flex;
      flex-direction: row;
      padding: 20px;
      max-width: 1200px;
      margin: auto;
    }
    .time-list {
      flex: 1.6;
      background: var(--card-bg);
      padding: 20px;
      border-radius: 12px;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
      margin-right: 20px;
    }
    .main-content {
      flex: 1.4;
      background: var(--card-bg);
      padding: 20px;
      border-radius: 12px;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
      text-align: center;
    }
    #scramble {
      font-size: 18px;
      margin-bottom: 18px;
      white-space: pre-line;
    }
#timer {
  font-size: 80px;
  font-weight: bold;
  margin: 20px 0;
  cursor: pointer;
  background-color: #e9ecef;
  border-radius: 12px;
  padding: 40px 20px;
  -webkit-tap-highlight-color: transparent;
  user-select: none;
  -webkit-user-select: none;
  -ms-user-select: none;
  touch-action: manipulation;
}

#typingInput {
  font-size: 80px;
  padding: 40px 20px;
  text-align: center;
  border: none;
  border-radius: 12px;
  background-color: #e9ecef;
  width: 100%;
  outline: none;
  box-sizing: border-box;
}


    #status {
      font-size: 16px;
      margin-bottom: 20px;
    }
    select {
      margin-bottom: 20px;
      padding: 8px;
      font-size: 16px;
    }
    button {
      margin: 5px;
      padding: 10px 18px;
      font-size: 16px;
      border-radius: 8px;
      border: none;
      cursor: pointer;
      background-color: var(--accent);
      color: white;
    }
    button:hover {
      background-color: var(--hover-accent);
    }
    table {
      width: 100%;
      border-collapse: collapse;
    }
    th, td {
      padding: 10px;
      text-align: center;
      border-bottom: 1px solid var(--table-border);
    }
    th {
      color: var(--text-color);
      font-size: 16px;
    }
    .ao5-cell {
      color: var(--ao5-color);
      font-weight: bold;
    }
    .hover-delete:hover {
      background-color: #ffe0e0;
      cursor: pointer;
    }
  @media (max-width: 768px) {
  .container {
    flex-direction: column-reverse;
  }

  .time-list {
    margin-right: 0;
    margin-top: 20px;
  }

  /* üëâ Scramble controls stacked vertically */
  .main-content > div:first-child {
    flex-direction: column;
    gap: 6px;
  }

  /* üëâ Smaller settings icon */
  #settingsBtn {
    font-size: 20px !important;
    top: 10px !important;
    right: 10px !important;
  }
}



#prevScrambleBtn:hover, #nextScrambleBtn:hover {
  color: var(--hover-accent);
  text-decoration: none;
}


  </style>




  <div class="container">
    <div class="time-list">
      <div style="display: flex; justify-content: space-between; align-items: center;">
        <h3 style="margin: 0;">Time List</h3>
        <button id="deleteBtn">Delete All</button>
      </div>
      <table>
        <thead>
          <tr>
          <th>Sr No.</th>
<th>Time</th>
<th>Mo3</th>
<th>Ao5</th>
<th>Ao12</th>
          </tr>
        </thead>
        <tbody id="solveList"></tbody>
      </table>
    </div>
    <div class="main-content">
 <div style="display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; margin-bottom: 10px; font-size: 16px; gap: 10px;">
  <!-- Settings Icon on Left -->
  <button id="settingsBtn" title="Settings" style="font-size: 20px; background: none; border: none; cursor: pointer;">‚öôÔ∏è</button>

  <!-- Event Dropdown in Center -->
  <div style="display: flex; align-items: center; gap: 8px;">
    <label for="eventSelect" style="font-weight: bold;">Event:</label>
    <select id="eventSelect"></select>
  </div>

  <!-- Last/Next Buttons on Right -->
  <div style="display: flex; align-items: center; gap: 6px;">
    <span id="prevScrambleBtn" style="color: var(--accent); cursor: pointer; text-decoration: underline;">Last</span> /
    <span id="nextScrambleBtn" style="color: var(--accent); cursor: pointer; text-decoration: underline;">Next</span>
  </div>
</div>








      <div id="scramble"></div>
      <div id="timer">0.00</div>
      <div id="status">Tap or press SPACE to start/stop</div>
<input id="typingInput" type="text" placeholder="Type Here" style="display: none; 
         padding: 20px; 
         font-size: 50px; 
         margin: 20px auto; 
         width: 80%; 
         border-radius: 12px; 
         border: 2px solid #ccc; 
         text-align: center; 
         box-sizing: border-box;">


      <button id="resetBtn">Reset Timer</button>
    </div>
  </div>

<!-- Settings Popup Modal -->
<div id="settingsModal" class="modal">
  <div class="modal-content">
    <span class="close">√ó</span>
    <h2>Settings</h2>
<div style="margin-bottom: 10px; font-size: 16px; display: flex; align-items: center; justify-content: center; gap: 10px;">
  <label for="inspectionToggle" style="font-weight: bold;">Inspection Time:</label>
  <input type="checkbox" id="inspectionToggle" checked>
  <span id="inspectionToggleLabel">ON</span>
</div>

<div style="margin-bottom: 10px; font-size: 16px; display: flex; align-items: center; justify-content: center; gap: 10px;">
  <label for="modeSelector" style="font-weight: bold;">Timer Mode:</label>
  <select id="modeSelector">
    <option value="Timer">Timer</option>
    <option value="Typing">Typing</option>
  </select>
</div>


    <!-- Add more settings here -->
  </div>
</div>

  <script>
    const eventScrambleGenerators = {
      "3x3": () => scrambleMoves("R L U D F B", 25),
      "2x2": () => scrambleMoves("R U F", 11),
      "4x4": () => scrambleMoves("R L U D F B Rw Uw Fw", 40),
      "5x5": () => scrambleMoves("R L U D F B Rw Uw Fw Lw Dw Bw", 60),
      "6x6": () => scrambleMoves("R L U D F B Rw Uw Fw Lw Dw Bw 3Rw 3Uw 3Fw", 80),
      "7x7": () => scrambleMoves("R L U D F B Rw Uw Fw Lw Dw Bw 3Rw 3Uw 3Fw 3Lw 3Bw 3Dw", 100),
      "Pyraminx": () => scramblePyraminx(),
      "Skewb": () => scrambleMoves("R L U B", 11, ["", "'"]),
      "Clock": () => scrambleClock(),
      "Megaminx": () => scrambleMegaminx(),
      "3x3 OH": () => scrambleMoves("R L U D F B", 25),
      "3BLD": () => scrambleMoves("R L U D F B", 20) + " " + scrambleMoves("Rw Uw Fw", Math.floor(Math.random() * 3))
    };

    const modifiers = ["", "'", "2"];
    const solveTimesByEvent = {};
    let currentEvent = "3x3";
    
    let solveTimes = []; // Each solve will be { time, penalty: 'ok' | '+2' | 'DNF', scramble }
let inspectionEnabled = true;
    let startTime, interval, running = false;
let scrambleHistory = [];
let scrambleIndex = -1;



    const eventSelect = document.getElementById("eventSelect");
    const scrambleDisplay = document.getElementById("scramble");
    const timerDisplay = document.getElementById("timer");
    const statusDisplay = document.getElementById("status");
    const solveList = document.getElementById("solveList");
const typingInput = document.getElementById("typingInput");

    Object.keys(eventScrambleGenerators).forEach(event => {
      const option = document.createElement("option");
      option.value = event;
      option.textContent = event;
      eventSelect.appendChild(option);
    });
    eventSelect.value = currentEvent;

    eventSelect.addEventListener("change", () => {
      solveTimesByEvent[currentEvent] = solveTimes;
      currentEvent = eventSelect.value;
      solveTimes = solveTimesByEvent[currentEvent] || [];
      updateSolveTable();
      generateScramble();
    });
 
typingInput.addEventListener("keydown", (e) => {
  if (e.key === "Enter") {
    const formatted = parseTypedTime(typingInput.value);

    if (formatted) {
      let ms = convertTimeToMs(formatted);
      addSolve(ms);
      typingInput.value = '';
      generateScramble();
    } else {
      typingInput.value = '';
    }
  }
});



function scrambleMoves(movesStr, length, allowedModifiers = modifiers) {
  const moves = movesStr.split(" ");
  let scramble = [];
  let last = "", secondLast = "";

  const getFace = (move) => {
    return move.match(/^[0-9]?([RLUDFB])/)[1]; // extracts face from R, Rw, 3Rw etc.
  };
  const isParallel = (a, b) => {
    const parallelGroups = [
      ["R", "L"], ["U", "D"], ["F", "B"]
    ];
    return parallelGroups.some(group => group.includes(a) && group.includes(b));
  };
  while (scramble.length < length) {
    const move = moves[Math.floor(Math.random() * moves.length)];
    const modifier = allowedModifiers[Math.floor(Math.random() * allowedModifiers.length)];
    const face = getFace(move);
    if (face === last) continue; // prevent immediate repeat
    if (last && secondLast && isParallel(face, last) && isParallel(last, secondLast)) continue;
    scramble.push(move + modifier);
    secondLast = last;
    last = face;
  }
  return scramble.join(" ");
}



    function scramblePyraminx() {
  const baseMoves = scrambleMoves("R L U B", 8, ["", "'"]); // No "2" moves allowed
  const tips = ["l", "r", "u", "b"];
  const tipModifiers = ["", "'"];
  let tipMoves = tips
    .sort(() => 0.5 - Math.random())
    .slice(0, Math.floor(Math.random() * 5))
    .map(t => t + tipModifiers[Math.floor(Math.random() * tipModifiers.length)]);
  return baseMoves + (tipMoves.length ? " " + tipMoves.join(" ") : "");
}


 function scrambleClock() {
  const positions = ["UR", "DR", "DL", "UL", "U", "R", "D", "L", "ALL", "y2", "U", "R", "D", "L", "ALL"];
  return positions.map(pos => {
    if (pos === "y2") return "y2"; // No number or +/-
    return `${pos}${Math.floor(Math.random() * 7)}${["+", "-"][Math.floor(Math.random() * 2)]}`;
  }).join(" ");
}


  function scrambleMegaminx() {
  const uMoves = ["U", "U'"];
  const rMoves = ["R++", "R--"];
  const dMoves = ["D++", "D--"];

  let out = [];

  for (let i = 0; i < 7; i++) {
    let line = [];

    // 5 pairs: R D R D R D R D R D ‚Üí 10 moves
    for (let j = 0; j < 5; j++) {
      line.push(rMoves[Math.floor(Math.random() * rMoves.length)]);
      line.push(dMoves[Math.floor(Math.random() * dMoves.length)]);
    }

    // Append one U or U'
    line.push(uMoves[Math.floor(Math.random() * uMoves.length)]);

    out.push(line.join(" "));
  }

  return out.join("\n");
}


    function formatTime(ms) {
      const s = ms / 1000;
     return s >= 60 ? `${Math.floor(s / 60)}:${(s % 60).toFixed(2).padStart(5, '0')}` : s.toFixed(2);
    }
 
function parseTypedTime(input) {
  input = input.trim();

  if (!/^\d{3,7}$/.test(input)) return null;

  const len = input.length;

  if (len === 3) {
    // s.ms
    return `${parseInt(input[0])}.${input.slice(1, 3)}`;
  }

  if (len === 4) {
    // ss.ms
    return `${parseInt(input.slice(0, 2))}.${input.slice(2, 4)}`;
  }

  if (len === 5) {
    // m:ss.ms
    return `${parseInt(input[0])}:${input.slice(1, 3)}.${input.slice(3, 5)}`;
  }

  if (len === 6) {
    // mm:ss.ms
    return `${input.slice(0, 2)}:${input.slice(2, 4)}.${input.slice(4, 6)}`;
  }

  if (len === 7) {
    // h:mm:ss.ms
    return `${input[0]}:${input.slice(1, 3)}:${input.slice(3, 5)}.${input.slice(5, 7)}`;
  }

  return null;
}




function convertTimeToMs(str) {
  if (str === 'DNF') return 'DNF';

  const parts = str.split(":").map(p => p.trim());
  let ms = 0;

  if (parts.length === 3) {
    // Format: h:mm:ss.ms
    const [h, m, s] = parts;
    ms += parseInt(h) * 3600000;
    ms += parseInt(m) * 60000;
    ms += parseFloat(s) * 1000;
  } else if (parts.length === 2) {
    // Format: m:ss.ms
    const [m, s] = parts;
    ms += parseInt(m) * 60000;
    ms += parseFloat(s) * 1000;
  } else {
    // Format: ss.ms
    ms += parseFloat(parts[0]) * 1000;
  }

  return Math.round(ms);
}




function generateScramble() {
  const newScramble = eventScrambleGenerators[currentEvent]();
  scrambleHistory.push(newScramble);
  scrambleIndex = scrambleHistory.length - 1;
  scrambleDisplay.textContent = "Scramble: " + newScramble;
}

document.getElementById("prevScrambleBtn").onclick = () => {
  if (scrambleIndex > 0) {
    scrambleIndex--;
    scrambleDisplay.textContent = "Scramble: " + scrambleHistory[scrambleIndex];
  }
};

document.getElementById("nextScrambleBtn").onclick = () => {
  // If we're not at the latest, move forward
  if (scrambleIndex < scrambleHistory.length - 1) {
    scrambleIndex++;
    scrambleDisplay.textContent = "Scramble: " + scrambleHistory[scrambleIndex];
  } else {
    // Else generate new
    generateScramble();
  }
};

let currentMode = "Timer";
const modeSelect = document.getElementById("modeSelect");



    function calculateAo5(index) {
      const last5 = solveTimes.slice(index - 4, index + 1);
      const sorted = [...last5].sort((a, b) => a - b);
      return (sorted[1] + sorted[2] + sorted[3]) / 3;
    }

function updateSolveTable() {
  solveList.innerHTML = '';
  for (let i = 0; i < solveTimes.length; i++) {
    const index = solveTimes.length - 1 - i;
    const solve = solveTimes[index];

    const row = document.createElement('tr');
    row.classList.add('hover-delete');
    row.onclick = (e) => {
      if (e.target.classList.contains('ao5-cell') || e.target.classList.contains('mo3-cell')) return;
      showPenaltyPopup(index);
    };

    const sr = document.createElement('td');
    sr.textContent = solveTimes.length - i;

    const time = document.createElement('td');
    time.textContent = formatTimeObj(solve);

    // === Mo3 Column ===
    const mo3 = document.createElement('td');
    if (index >= 2) {
      const last3 = solveTimes
        .slice(index - 2, index + 1)
        .map(s => s.penalty === 'DNF' ? Infinity : s.time + (s.penalty === '+2' ? 2000 : 0));
      const validTimes = last3.filter(t => t !== Infinity);
      const avg = validTimes.length === 3 ? validTimes.reduce((a, b) => a + b, 0) / 3 : Infinity;

      if (avg === Infinity) {
        mo3.textContent = 'DNF';
      } else {
        mo3.textContent = formatTime(avg);
        mo3.className = 'mo3-cell';
        mo3.style.cursor = 'pointer';

        mo3.addEventListener('click', (e) => {
          e.stopPropagation();
          showMo3Popup(index);
        });
      }
    } else {
      mo3.textContent = '-';
    }

    // === Ao5 Column ===
    const ao5 = document.createElement('td');
    if (index >= 4) {
      const last5 = solveTimes
        .slice(index - 4, index + 1)
        .map(s => s.penalty === 'DNF' ? Infinity : s.time + (s.penalty === '+2' ? 2000 : 0));
      const sorted = [...last5].sort((a, b) => a - b);
      const avg = (sorted[1] + sorted[2] + sorted[3]) / 3;

      if (avg === Infinity) {
        ao5.textContent = 'DNF';
      } else {
        ao5.textContent = formatTime(avg);
        ao5.className = 'ao5-cell';
        ao5.style.cursor = 'pointer';

        ao5.addEventListener('click', (e) => {
          e.stopPropagation();
          showAo5Popup(index);
        });
      }

      ao5.className = 'ao5-cell';
    } else {
      ao5.textContent = '-';
    }

// === Ao12 Column ===
const ao12 = document.createElement('td');
if (index >= 11) {
  const last12 = solveTimes
    .slice(index - 11, index + 1)
    .map(s => s.penalty === 'DNF' ? Infinity : s.time + (s.penalty === '+2' ? 2000 : 0));

  const valid = last12.filter(t => t !== Infinity);
  let avg = Infinity;

  if (valid.length >= 10) {
    const sorted = [...last12].sort((a, b) => a - b);
    const trimmed = sorted.slice(1, 11); // Remove best and worst
    avg = trimmed.reduce((a, b) => a + b, 0) / 10;
  }

  if (avg === Infinity) {
    ao12.textContent = 'DNF';
  } else {
    ao12.textContent = formatTime(avg);
    ao12.className = 'ao5-cell';
    ao12.style.cursor = 'pointer';
    ao12.addEventListener('click', (e) => {
      e.stopPropagation();
      showAo12Popup(index);
    });
  }
} else {
  ao12.textContent = '-';
}


    row.append(sr, time, mo3, ao5, ao12);
    solveList.appendChild(row);
  }
}




    function confirmDelete(index) {
      const confirmed = confirm(`Delete solve #${index + 1} (${formatTime(solveTimes[index])})?`);
      if (confirmed) {
        solveTimes.splice(index, 1);
        updateSolveTable();
      }
    }

    function resetTimer() {
      clearInterval(interval);
      running = false;
      timerDisplay.textContent = '0.00';
      statusDisplay.textContent = 'Tap or press SPACE to start/stop';
      generateScramble();
    }

    function deleteAll() {
      if (confirm("Delete all solves?")) {
        solveTimes = [];
        updateSolveTable();
      }
    }

    function addSolve(ms) {
      solveTimes.push({ time: ms, penalty: 'ok', scramble: scrambleDisplay.textContent.replace('Scramble: ', '') });
      updateSolveTable();
    }

    function toggleTimer() {
   if (currentMode !== "Timer") return;
   if (!running) {
        startTime = Date.now();
        interval = setInterval(() => {
          timerDisplay.textContent = formatTime(Date.now() - startTime);
        }, 10);
        running = true;
        statusDisplay.textContent = "Timing... Tap or press SPACE again to stop";
      } else {
        clearInterval(interval);
        running = false;
        const elapsed = Date.now() - startTime;
        addSolve(elapsed);
        timerDisplay.textContent = formatTime(elapsed);
        statusDisplay.textContent = "Tap or press SPACE to start/stop";
        generateScramble();
      }
    }

   let spacePressed = false;
let mouseDown = false;

// SPACEBAR hold
window.addEventListener("keydown", (e) => {
if (currentMode !== "Timer") return;
  if (e.code === 'Space' && window.innerWidth > 768) {
    e.preventDefault();
    timerDisplay.style.color = 'green';
  }
});
window.addEventListener("keyup", (e) => {
 if (currentMode !== "Timer") return;
 if (e.code === 'Space' && window.innerWidth > 768) {
    e.preventDefault();
    timerDisplay.style.color = 'red';
    toggleTimer();
  }
});



// MOUSE + TOUCH hold on timer (desktop + mobile support)
function handleHoldStart() {
if (currentMode !== "Timer") return;
  if (!mouseDown) {
    mouseDown = true;
    timerDisplay.style.color = 'green'; // Green on hold
  }
}

function handleHoldEnd() {
if (currentMode !== "Timer") return;
  if (mouseDown) {
    mouseDown = false;
    timerDisplay.style.color = 'red'; // Red for inspection
    toggleTimer(); // Start inspection or timer
  }
}

// Desktop support
timerDisplay.addEventListener("mousedown", handleHoldStart);
timerDisplay.addEventListener("mouseup", handleHoldEnd);

// Mobile support
timerDisplay.addEventListener("touchstart", (e) => {
  e.preventDefault(); // Prevents zoom/scroll
  handleHoldStart();
});
timerDisplay.addEventListener("touchend", (e) => {
  e.preventDefault();
  handleHoldEnd();
});



    document.getElementById("resetBtn").onclick = resetTimer;
    document.getElementById("deleteBtn").onclick = deleteAll;

const inspectionToggle = document.getElementById("inspectionToggle");
const inspectionToggleLabel = document.getElementById("inspectionToggleLabel");

inspectionToggle.addEventListener("change", () => {
  inspectionEnabled = inspectionToggle.checked;
  inspectionToggleLabel.textContent = inspectionEnabled ? "ON" : "OFF";
});



// Insert these variables at the top after your global declarations
let inspectionTime = 15000; // 15 seconds
let inspectionInterval;
let inspectionRunning = false;
let inspectionStart;
let penalty = null; // 'plus2' or 'dnf'

// Modify toggleTimer() with inspection logic
function toggleTimer() {
if (!running && !inspectionRunning) {
  if (!inspectionEnabled) {
    // Skip inspection, start timer directly
    startTime = Date.now();
    running = true;
    timerDisplay.style.color = 'green';
    statusDisplay.textContent = "Timing... Tap or press SPACE again to stop";
    interval = setInterval(() => {
      timerDisplay.style.color = 'black';
      timerDisplay.textContent = formatTime(Date.now() - startTime);
    }, 10);
    return;
  }


    // Start 15s inspection
    inspectionStart = Date.now();
    inspectionRunning = true;
    timerDisplay.style.color = 'red';
    statusDisplay.textContent = "Inspection... (15s) Tap or press SPACE to start";

    inspectionInterval = setInterval(() => {
      let elapsed = Date.now() - inspectionStart;
      let secondsLeft = 15 - elapsed / 1000;

      if (secondsLeft >= 0) {
        timerDisplay.textContent = secondsLeft.toFixed(2);
      } else if (secondsLeft >= -2) {
        penalty = 'plus2';
        timerDisplay.textContent = "+2";
      } else {
        penalty = 'dnf';
        clearInterval(inspectionInterval);
        inspectionRunning = false;
        timerDisplay.textContent = "DNF";
        statusDisplay.textContent = "Inspection expired - solve is DNF";
      }
    }, 50);

    return;
  }

  if (inspectionRunning) {
    clearInterval(inspectionInterval);
    inspectionRunning = false;

    if (penalty === 'dnf') {
      addSolve('DNF');
      timerDisplay.textContent = "DNF";
      statusDisplay.textContent = "Tap or press SPACE to start/stop";
      generateScramble();
      penalty = null;
      return;
    }

    // Start actual timer after inspection
    startTime = Date.now();
    running = true;
    timerDisplay.style.color = 'green';
    interval = setInterval(() => {
      timerDisplay.style.color = 'black';
      timerDisplay.textContent = formatTime(Date.now() - startTime);
    }, 10);

    statusDisplay.textContent = "Timing... Tap or press SPACE again to stop";
    return;
  }

  // Stop timer normally
  if (running) {
    clearInterval(interval);
    running = false;
    const elapsed = Date.now() - startTime;

 if (penalty === 'DNF') {
  addSolve(elapsed, 'DNF');
  timerDisplay.textContent = 'DNF';
} else if (penalty === 'plus2') {
  addSolve(elapsed, '+2');
  timerDisplay.textContent = formatTime(elapsed + 2000) + '+';
} else {
  addSolve(elapsed);
  timerDisplay.textContent = formatTime(elapsed);
}



    penalty = null;
    timerDisplay.style.color = 'black';
    statusDisplay.textContent = "Tap or press SPACE to start/stop";
    generateScramble();
  }
}

// Modify addSolve() to optionally mark +2
function addSolve(ms, penalty = 'ok', scramble = scrambleDisplay.textContent.replace('Scramble: ', '')) {
  solveTimes.push({ time: ms, penalty, scramble });
  updateSolveTable();
}

// Modify formatTime to handle DNF string
function formatTime(ms) {
  if (ms === 'DNF') return 'DNF';

  let totalMs = parseInt(ms);
  let totalSeconds = Math.floor(totalMs / 1000);
  let milliseconds = totalMs % 1000;
  let hundredths = Math.round(milliseconds / 10).toString().padStart(2, '0');

  if (totalSeconds < 60) {
    return `${totalSeconds}.${hundredths}`;
  }

  const seconds = totalSeconds % 60;
  const minutes = Math.floor((totalSeconds % 3600) / 60);
  const hours = Math.floor(totalSeconds / 3600);

  const paddedSeconds = seconds.toString().padStart(2, '0');

  if (totalSeconds < 3600) {
    return `${minutes}:${paddedSeconds}.${hundredths}`; // mm:ss.ms
  }

  const paddedMinutes = minutes.toString().padStart(2, '0');
  return `${hours}:${paddedMinutes}:${paddedSeconds}.${hundredths}`; // h:mm:ss.ms
}





function formatTimeObj(solve) {
  if (solve.penalty === 'DNF') return 'DNF';
  
  const adjustedTime = solve.time + (solve.penalty === '+2' ? 2000 : 0);
  const base = formatTime(adjustedTime);

  return solve.penalty === '+2' ? base + '+' : base;
}

function showMo3Popup(index) {
  const solves = solveTimes.slice(index - 2, index + 1);
  if (solves.length < 3) return;

  const times = solves.map(s =>
    s.penalty === 'DNF' ? Infinity : s.time + (s.penalty === '+2' ? 2000 : 0)
  );

  const today = new Date().toISOString().slice(0, 10);
  const validTimes = times.filter(t => t !== Infinity);
  const avg = validTimes.length === 3 ? validTimes.reduce((a, b) => a + b, 0) / 3 : Infinity;

  let message = `Generated By The Cubeology Timer on ${today}\n`;
  message += `mean of 3: ${avg === Infinity ? 'DNF' : formatTime(avg)}\n\n`;
  message += `Time List:\n`;

  for (let i = 0; i < 3; i++) {
    const solve = solves[i];
    const display = formatTimeObj(solve);
    message += `${i + 1}. ${display}   ${solve.scramble}\n`;
  }

  const popup = document.createElement('div');
  popup.style.position = 'fixed';
  popup.style.top = '50%';
  popup.style.left = '50%';
  popup.style.transform = 'translate(-50%, -50%)';
  popup.style.background = '#fff';
  popup.style.padding = '20px';
  popup.style.boxShadow = '0 0 10px rgba(0,0,0,0.2)';
  popup.style.zIndex = '9999';
  popup.style.maxWidth = '90%';
  popup.style.maxHeight = '80%';
  popup.style.overflow = 'auto';
  popup.style.whiteSpace = 'pre-wrap';
  popup.style.fontFamily = 'monospace';
  popup.style.borderRadius = '12px';

  const pre = document.createElement('pre');
  pre.textContent = message;

  const copyBtn = document.createElement('button');
  copyBtn.textContent = "Copy";
  copyBtn.onclick = () => {
    navigator.clipboard.writeText(message);
    copyBtn.textContent = "Copied!";
    setTimeout(() => copyBtn.textContent = "Copy", 2000);
  };

  const closeBtn = document.createElement('button');
  closeBtn.textContent = "Close";
  closeBtn.style.marginLeft = '10px';
  closeBtn.onclick = () => popup.remove();

  popup.append(pre, copyBtn, closeBtn);
  document.body.appendChild(popup);
}



function showAo5Popup(index) {
  const solves = solveTimes.slice(index - 4, index + 1);
  if (solves.length < 5) return;

  const times = solves.map(s =>
    s.penalty === 'DNF' ? Infinity : s.time + (s.penalty === '+2' ? 2000 : 0)
  );

  const sorted = [...times].map((t, i) => ({ time: t, idx: i }))
    .sort((a, b) => a.time - b.time);

  const bestIdx = sorted[0].time === Infinity ? null : sorted[0].idx;
  const worstIdx = sorted[4].time === Infinity ? null : sorted[4].idx;

  const today = new Date().toISOString().slice(0, 10);

  let message = `Generated By The Cubeology Timer on ${today}\n`;
  const validTimes = times.filter(t => t !== Infinity);
  const avg = validTimes.length >= 3 ? (validTimes.sort((a, b) => a - b).slice(1, 4).reduce((a, b) => a + b, 0) / 3) : Infinity;
  message += `avg of 5: ${avg === Infinity ? 'DNF' : formatTime(avg)}\n\n`;
  message += `Time List:\n`;

  const popup = document.createElement('div');
  popup.style.position = 'fixed';
  popup.style.top = '50%';
  popup.style.left = '50%';
  popup.style.transform = 'translate(-50%, -50%)';
  popup.style.background = '#fff';
  popup.style.padding = '20px';
  popup.style.boxShadow = '0 0 10px rgba(0,0,0,0.2)';
  popup.style.zIndex = '9999';
  popup.style.maxWidth = '90%';
  popup.style.maxHeight = '80%';
  popup.style.overflow = 'auto';
  popup.style.whiteSpace = 'pre-wrap';
  popup.style.fontFamily = 'monospace';
  popup.style.borderRadius = '12px';

  const pre = document.createElement('pre');

  for (let i = 0; i < 5; i++) {
    const solve = solves[i];
    let display = formatTimeObj(solve);
    if (i === bestIdx || i === worstIdx) display = `(${display})`;
    message += `${i + 1}. ${display}   ${solve.scramble}\n`;
  }

  pre.textContent = message;

  const copyBtn = document.createElement('button');
  copyBtn.textContent = "Copy";
  copyBtn.onclick = () => {
    navigator.clipboard.writeText(message);
    copyBtn.textContent = "Copied!";
    setTimeout(() => copyBtn.textContent = "Copy", 2000);
  };

  const closeBtn = document.createElement('button');
  closeBtn.textContent = "Close";
  closeBtn.style.marginLeft = '10px';
  closeBtn.onclick = () => popup.remove();

  // üëâ Add 1 Solve Stat buttons under each solve
for (let i = 0; i < 5; i++) {
  const solveIndex = index - 4 + i; // actual index in solveTimes
  const btn = document.createElement('button');
  btn.textContent = `1 Solve Stat #${i + 1}`;
  btn.style.margin = '5px';
  btn.onclick = () => {
    setTimeout(() => {
      showSingleSolveStat(solveIndex);
    }, 0);
    popup.remove();
  };
  popup.appendChild(btn);
}


  popup.append(pre, copyBtn, closeBtn);
  document.body.appendChild(popup);
}

function showAo12Popup(index) {
  const solves = solveTimes.slice(index - 11, index + 1);
  if (solves.length < 12) return;

  const times = solves.map(s =>
    s.penalty === 'DNF' ? Infinity : s.time + (s.penalty === '+2' ? 2000 : 0)
  );

  const today = new Date().toISOString().slice(0, 10);
  const validTimes = times.filter(t => t !== Infinity);
  const sorted = [...times].map((t, i) => ({ time: t, idx: i })).sort((a, b) => a.time - b.time);

  const bestIdx = sorted[0].time === Infinity ? null : sorted[0].idx;
  const worstIdx = sorted[sorted.length - 1].time === Infinity ? null : sorted[sorted.length - 1].idx;

  const trimmed = sorted.slice(1, 11).filter(obj => obj.time !== Infinity);
  const avg = trimmed.length === 10 ? trimmed.reduce((sum, obj) => sum + obj.time, 0) / 10 : Infinity;

  let message = `Generated By The Cubeology Timer on ${today}\n`;
  message += `avg of 12: ${avg === Infinity ? 'DNF' : formatTime(avg)}\n\n`;
  message += `Time List:\n`;

  const popup = document.createElement('div');
  popup.style.position = 'fixed';
  popup.style.top = '50%';
  popup.style.left = '50%';
  popup.style.transform = 'translate(-50%, -50%)';
  popup.style.background = '#fff';
  popup.style.padding = '20px';
  popup.style.boxShadow = '0 0 10px rgba(0,0,0,0.2)';
  popup.style.zIndex = '9999';
  popup.style.maxWidth = '90%';
  popup.style.maxHeight = '80%';
  popup.style.overflow = 'auto';
  popup.style.whiteSpace = 'pre-wrap';
  popup.style.fontFamily = 'monospace';
  popup.style.borderRadius = '12px';

  const pre = document.createElement('pre');

  for (let i = 0; i < 12; i++) {
    const solve = solves[i];
    let display = formatTimeObj(solve);
    if (i === bestIdx || i === worstIdx) display = `(${display})`;
    message += `${i + 1}. ${display}   ${solve.scramble}\n`;
  }

  pre.textContent = message;

  const copyBtn = document.createElement('button');
  copyBtn.textContent = "Copy";
  copyBtn.onclick = () => {
    navigator.clipboard.writeText(message);
    copyBtn.textContent = "Copied!";
    setTimeout(() => copyBtn.textContent = "Copy", 2000);
  };

  const closeBtn = document.createElement('button');
  closeBtn.textContent = "Close";
  closeBtn.style.marginLeft = '10px';
  closeBtn.onclick = () => popup.remove();

  popup.append(pre, copyBtn, closeBtn);
  document.body.appendChild(popup);
}



function showPenaltyPopup(index) {
  const solve = solveTimes[index];

  const popup = document.createElement('div');
  popup.style.position = 'fixed';
  popup.style.top = '50%';
  popup.style.left = '50%';
  popup.style.transform = 'translate(-50%, -50%)';
  popup.style.background = '#fff';
  popup.style.padding = '20px';
  popup.style.boxShadow = '0 0 10px rgba(0,0,0,0.2)';
  popup.style.zIndex = '9999';
  popup.style.borderRadius = '10px';
  popup.style.fontFamily = 'Segoe UI, sans-serif';
  popup.style.textAlign = 'center';

  const title = document.createElement('h3');
title.textContent = `Solve #${index + 1}`;
  popup.appendChild(title);

  const timeDisplay = document.createElement('p');
  timeDisplay.textContent = `Time: ${formatTimeObj(solve)}`;
  popup.appendChild(timeDisplay);

  // ‚úÖ Add scramble display
  const scrambleDisplay = document.createElement('p');
  scrambleDisplay.textContent = `Scramble: ${solve.scramble}`;
  popup.appendChild(scrambleDisplay);
const statBtn = document.createElement('button');
statBtn.textContent = "1 Solve Stat";
statBtn.style.margin = '5px';
statBtn.onclick = () => {
  setTimeout(() => {
    showSingleSolveStat(index);
  }, 0);
  popup.remove();
};


popup.appendChild(statBtn);


  const btns = ['OK', '+2', 'DNF'].map(label => {
    const btn = document.createElement('button');
    btn.textContent = label;
    btn.style.margin = '5px';
    btn.onclick = () => {
      setPenalty(index, label === 'OK' ? 'ok' : label);
      popup.remove();
    };
    return btn;
  });

  const delBtn = document.createElement('button');
  delBtn.textContent = "Delete";
  delBtn.style.margin = '5px';
  delBtn.style.background = '#dc3545';
  delBtn.onclick = () => {
    deleteSolve(index);
    popup.remove();
  };

  const closeBtn = document.createElement('button');
  closeBtn.textContent = "Close";
  closeBtn.style.margin = '5px';
  closeBtn.onclick = () => popup.remove();

  popup.append(...btns, delBtn, closeBtn);
  document.body.appendChild(popup);
}


  function setPenalty(index, penalty) {
    solveTimes[index].penalty = penalty;
    updateSolveTable();
  }

  function deleteSolve(index) {
    solveTimes.splice(index, 1);
    updateSolveTable();
  }
function showSingleSolveStat(index) {
  const solve = solveTimes[index];
  const today = new Date().toISOString().slice(0, 10);
  let message = `Generated By The Cubeology Timer on ${today}\n\n`;
  message += `Time List :\n`;
  message += `1. ${formatTimeObj(solve)}  ${solve.scramble}`;

  const popup = document.createElement('div');
  popup.style.position = 'fixed';
  popup.style.top = '50%';
  popup.style.left = '50%';
  popup.style.transform = 'translate(-50%, -50%)';
  popup.style.background = '#fff';
  popup.style.padding = '20px';
  popup.style.boxShadow = '0 0 10px rgba(0,0,0,0.2)';
  popup.style.zIndex = '9999';
  popup.style.maxWidth = '90%';
  popup.style.maxHeight = '80%';
  popup.style.overflow = 'auto';
  popup.style.whiteSpace = 'pre-wrap';
  popup.style.fontFamily = 'monospace';
  popup.style.borderRadius = '12px';

  const pre = document.createElement('pre');
  pre.textContent = message;

  const copyBtn = document.createElement('button');
  copyBtn.textContent = "Copy";
  copyBtn.onclick = () => {
    navigator.clipboard.writeText(message);
    copyBtn.textContent = "Copied!";
    setTimeout(() => copyBtn.textContent = "Copy", 2000);
  };

  const closeBtn = document.createElement('button');
  closeBtn.textContent = "Close";
  closeBtn.style.marginLeft = '10px';
  closeBtn.onclick = () => popup.remove();

  popup.append(pre, copyBtn, closeBtn);
  document.body.appendChild(popup);
}

generateScramble();

  const settingsBtn = document.getElementById('settingsBtn');
  const settingsModal = document.getElementById('settingsModal');
  const closeBtn = settingsModal.querySelector('.close');

const modeSelector = document.getElementById('modeSelector');


modeSelector.addEventListener('change', () => {
currentMode = modeSelector.value;
if (modeSelector.value === 'Typing') {
  typingInput.style.display = 'block';
  timerDisplay.style.display = 'none';
  statusDisplay.style.display = 'none';
  typingInput.focus(); // üëà Add this
} else {
  typingInput.style.display = 'none';
  timerDisplay.style.display = 'block';
  statusDisplay.style.display = 'block';
}



  if (modeSelector.value === 'Typing') {
    typingInput.style.display = 'block';
    timerDisplay.style.display = 'none';
    statusDisplay.style.display = 'none';
  } else {
    typingInput.style.display = 'none';
    timerDisplay.style.display = 'block';
    statusDisplay.style.display = 'block';
  }
});


  // Open modal on button click
  settingsBtn.onclick = () => {
    settingsModal.style.display = 'block';
  };

  // Close modal on X click
  closeBtn.onclick = () => {
    settingsModal.style.display = 'none';
  };

  // Close modal when clicking outside the popup
  window.onclick = (e) => {
    if (e.target === settingsModal) {
      settingsModal.style.display = 'none';
    }
  };
window.addEventListener('keydown', function (e) {
  if (currentMode === 'Typing') return; // Disable in Typing mode
  if (e.key === 'Backspace') {
    deleteLastSolve();
  }
});



function deleteLastSolve() {
  if (solveTimes.length === 0) return;

  const confirmed = confirm(`Delete last solve: ${formatTimeObj(solveTimes[solveTimes.length - 1])}?`);
  if (confirmed) {
    solveTimes.pop();
    updateSolveTable();
  }
}

    
window.addEventListener('keydown', function (e) {
  if (currentMode === 'Typing') return; // Disable in Typing mode
  if (e.key === 'Delete') {
    deleteAllSolves();
  }
});



function deleteAllSolves() {
  if (solveTimes.length === 0) return;

  const confirmed = confirm("Are you sure you want to delete ALL solves?");
  if (confirmed) {
    solveTimes = [];
    updateSolveTable();
  }
}


</script>














</body>